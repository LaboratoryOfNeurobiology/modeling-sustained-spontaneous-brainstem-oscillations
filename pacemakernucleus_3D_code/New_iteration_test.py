import numpy as np
import time


def new_iteration(results, nodes_discrete, No_old, Cu, num_div, sol_range, it_step):
    """
    Using simulation results for current grid, generates refined grid (nodes and cubes) for the next interval halving
    iteration step.

    :param results: 2D numpy array associated with iteration step it_step where rows correspond to grid points at which
    simulations have just been run, and columns are associated with respective coordinate values except for the last
    column which contains respective oscillation frequency values (use the small negative value -1e-15 for zero
    oscillation frequencies)
    :param nodes_discrete: a tuple of tuples that contain discrete coordinates for all nodes at which frequency values
    have just been computed, it is associated with iteration step it_step
    :param No_old: dictionary that contains all discrete nodes that have been computed as keys, and corresponding
    frequencies as values, both up to iteration step (it_step - 1)
    :param Cu: tuple of tuples that contain (discrete) nodes of n-cubes, Cu is particular to it_step
    :param sol_range: 2D array where first dimension corresponds to coordinates and the second to lower and upper
    limits
    :param num_div: 1D array that corresponds to the initial number of divisions along each coordinate
    :param it_step: integer that marks the iteration step at which results were generated (for initialization use
    it_step = 0)

    :return: (nodes_scaled, nodes_discrete, No, Cu_new), where
            -   nodes_scaled: a numpy array where rows correspond to new grid points at which simulations have to be
                run, and columns are associated with respective coordinate values
            -   nodes_discrete: tuple of tuples containing discrete (unscaled) coordinates of nodes at which new
                simulations have to be run
            -   No: dictionary that contains all discrete nodes that have been computed as keys, and corresponding
                frequencies as values, both up to iteration step it_step
            -   Cu_new: a tuple of tuples that contain (discrete) nodes of n-cubes, Cu is particular to the
                new iteration step
    """

    t_overall_start = time.perf_counter()

    eps = np.finfo(float).eps                     # tolerance for zero detection
    s_range = np.array(sol_range)
    n_div = np.array(num_div)
    n_dim = len(num_div)            # number of coordinates
    n_nodes_per_cube = 2 ** n_dim   # number of nodes per cube

    # initial step sizes along coordinates
    D_0 = (s_range[:, 1] - s_range[:, 0]) / n_div

    # current step sizes
    D_it = D_0 / (2 ** it_step)

    # cube increment matrix
    D_cube = np.zeros((n_nodes_per_cube, n_dim))
    for i in range(n_nodes_per_cube):
        D_cube[i, :] = i // (2 ** (n_dim - 1 - np.arange(0, n_dim))) % 2

    # generating all sub-cubes and their nodes
    No_halved = ((1,)*n_dim,)  # all discrete nodes that are new or might be new
    Cu_halved = ()  # all sub-cubes generated by splitting the mother cube
    ind_No_halved = (True,)
    for i in range(n_nodes_per_cube):
        shift_i = D_cube[i, :]
        for j in range(n_nodes_per_cube):
            node_ij = tuple(D_cube[j, :] + shift_i)
            ind_No_halved += ((node_ij not in No_halved) and (node_ij != (1,)*n_dim) and (1 in node_ij),)
            No_halved += (node_ij,)
            Cu_halved += (node_ij,)

    # all discrete nodes that are new or might be new
    no_halved = np.array(No_halved)[np.array(ind_No_halved)]
    n_nodes_to_check = no_halved.shape[0] - 1
    # all sub-cubes generated by splitting the mother cube
    cu_halved = np.array(Cu_halved)

    # adding frequencies to node dictionary
    No = {}
    for key in No_old:
        key_new = tuple(np.array(key) * 2)
        No[key_new] = No_old[key]

    for i in range(len(nodes_discrete)):
        No[nodes_discrete[i]] = results[i, -1]

    t1_start = time.perf_counter()
    # Marking bracketing cubes
    is_bracketing = ()
    for nodes in Cu:
        sum_sign = 0
        for node in nodes:
            gr = No[node] > eps
            le = No[node] < -eps
            sum_sign += int(gr) - int(le)
        is_bracketing += ((sum_sign != n_nodes_per_cube) and (sum_sign != -n_nodes_per_cube),)
    # Collecting bracketing cubes
    Cu_br = np.array(Cu)[np.array(is_bracketing)]
    t1_end = time.perf_counter()
    print('\nFinding bracketing cubes: t=', t1_end-t1_start)

    # halved, new step sizes
    D_new = D_it/2

    # rescaling discrete node coordinates (considering halved step size)
    No_new = {}
    for key in No:
        key_new = tuple(np.array(key) * 2)
        No_new[key_new] = No[key]

    # tuple containing all newly generated nodes
    nodes_discrete = ()

    n_br_cube = len(Cu_br)
    n_sub_cube_nodes = n_nodes_per_cube**2
    cubes_new = np.zeros((n_br_cube*n_sub_cube_nodes, n_dim))
    t2, t3, t4, t5 = 0, 0, 0, 0
    for j in range(n_br_cube):
        node_min = np.array(Cu_br[j][0])*2                          # minimal node of mother cube

        t2_j_start = time.perf_counter()
        cubes_new[j*n_sub_cube_nodes:(j+1)*n_sub_cube_nodes, :] = cu_halved + node_min       # generating all sub-cubes
        t2_j_end = time.perf_counter()

        t2 += t2_j_end-t2_j_start

        t3_j_start = time.perf_counter()
        nodes_halved = no_halved + node_min  # generating all nodes of sub-cubes
        t3_j_end = time.perf_counter()

        t3 += t3_j_end-t3_j_start

        # collecting node which is surely not inside nodes_collected
        nodes_discrete += (tuple(nodes_halved[0, :]),)
        # collecting nodes which might be already inside nodes_collected
        for i in range(n_nodes_to_check):

            t4_j_start = time.perf_counter()
            node_i = tuple(nodes_halved[i + 1, :],)
            t4_j_end = time.perf_counter()

            t4 += t4_j_end-t4_j_start

            t5_j_start = time.perf_counter()
            if node_i not in No_new:
                No_new[node_i] = np.nan
                nodes_discrete += (node_i,)
            t5_j_end = time.perf_counter()

            t5 += t5_j_end-t5_j_start

    print('Shifting sub-cubes: t=', t2)
    print('Sifting nodes: t=', t3)
    print('Converting nodes: t=', t4)
    print('Checking whether node exists: t=', t5)

    # converting all sub-cubes to tuples
    Cu_new = ()

    t7_start = time.perf_counter()
    for i in range(n_nodes_per_cube*n_br_cube):
        Cu_new += (tuple([tuple(x) for x in cubes_new[i*n_nodes_per_cube:(i+1)*n_nodes_per_cube, :]]),)
    t7_end = time.perf_counter()
    t7 = t7_end-t7_start
    print('Conversion of sub-cubes to tuples: t=', t7)

    # number of new nodes
    n_node_new = len(nodes_discrete)
    print('Iteration #' + str(it_step) + ' has been completed.')
    print('Total number of nodes computed:', len(No), ' | Number of nodes to be simulated in iteration #' +
          str(it_step+1) + ':', len(nodes_discrete))

    # separating nodes for which simulations have not been run yet
    nodes_scaled = np.zeros((n_node_new, n_dim))
    for i in range(n_node_new):
        nodes_scaled[i, :] = np.array(nodes_discrete[i]) * D_new + s_range[:, 0]

    t_overall_end = time.perf_counter()
    print('Overall time consumption: t=', t_overall_end - t_overall_start)

    return nodes_scaled, nodes_discrete, No, Cu_new

